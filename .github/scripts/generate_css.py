#!/usr/bin/env python3
"""
Jellyfin Wallpaper CSS Generator
Generates CSS for an animated background slideshow with 3s display + 1s transition per image.
"""

import os
import sys
import math

# ========= CONFIGURATION =========
# GitHub repository details for jsDelivr URLs
GITHUB_USER = "AllStar112"
REPO_NAME = "Jellyfin-wallpaper"
BRANCH = "main"

# Path to the local wallpapers folder (relative to this script)
WALLPAPERS_FOLDER = "wallpapers"

# Output CSS file
OUTPUT_CSS_FILE = "wallpaper.css"

# Timing (in seconds)
DISPLAY_TIME = 3  # Time each image is fully visible
FADE_TIME = 1     # Time for crossfade to next image
# ================================

def get_jsdelivr_url(filename):
    """Generate a jsDelivr CDN URL for a filename."""
    encoded_name = filename.replace(" ", "%20")
    return f"https://cdn.jsdelivr.net/gh/{GITHUB_USER}/{REPO_NAME}@{BRANCH}/wallpapers/{encoded_name}"

def get_image_files():
    """Get a sorted list of image files from the wallpapers folder."""
    image_extensions = ('.jpg', '.jpeg', '.png', '.webp', '.bmp', '.gif')
    images = []
    
    try:
        for file in os.listdir(WALLPAPERS_FOLDER):
            if file.lower().endswith(image_extensions):
                images.append(file)
    except FileNotFoundError:
        print(f"ERROR: Folder '{WALLPAPERS_FOLDER}' not found.")
        sys.exit(1)
    
    if not images:
        print(f"ERROR: No images found in '{WALLPAPERS_FOLDER}'.")
        sys.exit(1)
    
    images.sort()
    return images

def calculate_keyframes(images):
    """
    Calculate the keyframe percentages based on your formula.
    
    For N images:
    - Total cycle time = N * (DISPLAY_TIME + FADE_TIME) seconds
    - Each image gets a 'display block' and a 'fade-out block'.
    - The transition from the last image back to the first must also be 1 second.
    """
    n = len(images)
    total_cycle_time = n * (DISPLAY_TIME + FADE_TIME)
    
    # Time per segment (display or fade) as a percentage of total cycle
    display_pct = (DISPLAY_TIME / total_cycle_time) * 100
    fade_pct = (FADE_TIME / total_cycle_time) * 100
    
    keyframes = []
    
    for i, img in enumerate(images):
        # Start of this image's display block
        start_display = i * (display_pct + fade_pct)
        # End of this image's display block (start of fade)
        end_display = start_display + display_pct
        # End of this image's fade block
        end_fade = end_display + fade_pct
        
        # For the last image, the fade block transitions back to image 0
        if i == n - 1:
            # The 100% keyframe is handled separately to close the loop
            keyframes.append({
                'img': img,
                'start': start_display,
                'display_end': end_display,
                'fade_end': 100.0  # The fade ends at 100%
            })
        else:
            keyframes.append({
                'img': img,
                'start': start_display,
                'display_end': end_display,
                'fade_end': end_fade
            })
    
    return keyframes, total_cycle_time

def generate_css(images):
    """Generate the complete CSS file content."""
    
    keyframes, total_cycle_time = calculate_keyframes(images)
    n = len(images)
    
    css_lines = []
    css_lines.append("/* Background Slideshow untuk .backgroundContainer */")
    css_lines.append("/* Auto-generated by script - DO NOT EDIT MANUALLY */")
    css_lines.append("/* Total Images: {} | Display: {}s | Fade: {}s | Cycle: {}s */".format(
        n, DISPLAY_TIME, FADE_TIME, total_cycle_time))
    css_lines.append("")
    css_lines.append("@keyframes backgroundSlideshow {")
    
    # Generate keyframe blocks
    for i, kf in enumerate(keyframes):
        img_url = get_jsdelivr_url(kf['img'])
        
        css_lines.append(f"  /* Image {i+1}: {kf['img']} */")
        css_lines.append(f"  {kf['start']:.4f}%, {kf['display_end']:.4f}% {{")
        css_lines.append(f"    background-image: url('{img_url}');")
        css_lines.append(f"  }}")
        
        # The transition happens between display_end% and fade_end%
        # For the last image, fade_end is 100%, which will loop back to image 0% (first image)
    
    # Close the keyframes
    first_img_url = get_jsdelivr_url(images[0])
    css_lines.append(f"  100% {{")
    css_lines.append(f"    background-image: url('{first_img_url}');")
    css_lines.append(f"  }}")
    css_lines.append("}")
    css_lines.append("")
    
    # Add the main .backgroundContainer styles (EXACTLY as in your template)
    css_lines.append("/* Hanya terapkan ke .backgroundContainer */")
    css_lines.append(".backgroundContainer {")
    css_lines.append(f"  animation: backgroundSlideshow {total_cycle_time}s infinite ease-in-out !important;")
    css_lines.append("  background-size: cover !important;")
    css_lines.append("  background-position: center !important;")
    css_lines.append("  background-repeat: no-repeat !important;")
    css_lines.append("  background-attachment: fixed !important;")
    css_lines.append("  transition: background-image 1s ease-in-out !important;")  # Matches your FADE_TIME
    css_lines.append("}")
    css_lines.append("")
    
    # Add the overlay
    css_lines.append("/* Efek overlay agar konten tetap terbaca */")
    css_lines.append(".backgroundContainer::before {")
    css_lines.append('  content: "" !important;')
    css_lines.append("  position: absolute !important;")
    css_lines.append("  top: 0 !important;")
    css_lines.append("  left: 0 !important;")
    css_lines.append("  width: 100% !important;")
    css_lines.append("  height: 100% !important;")
    css_lines.append("  background: rgba(0, 0, 0, 0.6) !important;")
    css_lines.append("  z-index: 0 !important;")
    css_lines.append("}")
    
    return "\n".join(css_lines)

def main():
    print("=== Jellyfin Wallpaper CSS Generator ===")
    print(f"Scanning folder: {WALLPAPERS_FOLDER}")
    
    images = get_image_files()
    print(f"Found {len(images)} images: {', '.join(images[:3])}{'...' if len(images) > 3 else ''}")
    
    css_content = generate_css(images)
    
    with open(OUTPUT_CSS_FILE, 'w', encoding='utf-8') as f:
        f.write(css_content)
    
    print(f"‚úÖ CSS generated: {OUTPUT_CSS_FILE}")
    print(f"‚è±Ô∏è  Total cycle time: {len(images) * (DISPLAY_TIME + FADE_TIME)} seconds")
    print(f"üìã Copy the contents of '{OUTPUT_CSS_FILE}' to Jellyfin Dashboard ‚Üí General ‚Üí Custom CSS")

if __name__ == "__main__":
    main()
